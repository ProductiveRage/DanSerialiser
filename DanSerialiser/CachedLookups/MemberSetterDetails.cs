using System;
using System.Linq.Expressions;
using static DanSerialiser.CachedLookups.BinarySerialisationWriterCachedNames;

namespace DanSerialiser // Note that this is not in the CachedLookeds namespace because it's needs part of the public API (and I would prefer for consumers to only need a single "using DanSerialiser")
{
	/// <summary>
	/// A BinarySerialisationWriter 'member setter' is writing field and property values for an instance of a particular type during the serialisation process. It does not
	/// have to write the ObjectStart and ObjectEnd headers for the instance because it needs to be possible for the Serialiser class to track references and if the same
	/// reference appears in the data-to-be-serialised multiple times then the Serialiser might be configured to record just a ReferenceID for the second occurrence,
	/// rather than repeating all of the field and property values again.
	/// 
	/// Instances of this class also contain internal data, visible only to the serialisation library - this is why there is no public constructor (because it would not be
	/// possible to fully initialise an instance of this class from external code, MemberSetterDetails instances must be generated by the serialiser library).
	/// </summary>
	public sealed class MemberSetterDetails
	{
		internal MemberSetterDetails(Type type, LambdaExpression memberSetter, CachedNameData typeName, CachedNameData[] fieldsSet)
		{
			if (memberSetter == null)
				throw new ArgumentNullException(nameof(memberSetter));
			if ((memberSetter.Parameters.Count != 2)
			|| (memberSetter.Parameters[0].Type != type)
			|| (memberSetter.Parameters[1].Type != typeof(BinarySerialisationWriter))
			|| (memberSetter.ReturnType != typeof(void)))
				throw new ArgumentException($"The {nameof(memberSetter)} lambda expression must have two parameters - {type} and {nameof(BinarySerialisationWriter)} - and void return type");

			Type = type ?? throw new ArgumentNullException(nameof(type));
			MemberSetter = memberSetter;
			TypeName = typeName ?? throw new ArgumentNullException(nameof(typeName));
			FieldsSet = fieldsSet ?? throw new ArgumentNullException(nameof(fieldsSet));
		}

		public Type Type { get; }

		/// <summary>
		/// This LambdaExpression will have two parameters, the first matching the Type property of the instance and the second being of type BinarySerialisationWriter.
		/// It will have no return type. When the lambda is invoked, the field and property values for the instance of the Type will be serialised using the specified
		/// BinarySerialisationWriter.
		/// </summary>
		public LambdaExpression MemberSetter { get; }

		internal CachedNameData TypeName { get; }
		internal CachedNameData[] FieldsSet { get; }

		internal Action<object, BinarySerialisationWriter> GetCompiledMemberSetter()
		{
			var sourceParameter = Expression.Parameter(typeof(object), "source");
			var writerParameter = Expression.Parameter(typeof(BinarySerialisationWriter), "writer");
			return
				Expression.Lambda<Action<object, BinarySerialisationWriter>>(
					Expression.Invoke(
						MemberSetter,
						Expression.Convert(sourceParameter, Type),
						writerParameter
					),
					sourceParameter,
					writerParameter
				)
				.Compile();
		}
	}
}